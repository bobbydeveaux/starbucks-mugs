## Code Review - Changes Requested

## ❌ BLOCKING ISSUES FOUND

PR #236 — `feat: implement AlertService RPCs with persistence and WebSocket fan-out`

The implementation is well-structured with good test coverage and documentation. However, two issues require fixes before merging.

---

### BLOCKING — Server crash via oversized WebSocket frame

**File:** `internal/server/websocket/handler.go:235-254` (readLoop)

```go
case 127:
    var ext [8]byte
    if _, err := buf.Read(ext[:]); err != nil {
        return
    }
    length = int64(binary.BigEndian.Uint64(ext[:]))  // ← overflow
// ...
discarded := make([]byte, length)  // ← panics when length < 0
```

`binary.BigEndian.Uint64` returns a `uint64`. Any value greater than `math.MaxInt64` (e.g., `0xFFFFFFFFFFFFFFFF`) overflows to a negative `int64`. The subsequent `make([]byte, length)` with a negative length panics with `makeslice: len out of range`.

The `readLoop` goroutine is launched without a `recover()`:
```go
go func() {
    defer close(done)
    readLoop(conn, h.logger, clientID)   // panic here crashes the process
    closeOnce()
}()
```

The WebSocket handler has no authentication check, so any network-reachable client can send a frame with the 8-byte extended length set to `0xFFFFFFFFFFFFFFFF`, crash the entire dashboard process, and knock out the security monitoring system.

**Fix:** Cap `length` after the conversion, e.g.:
```go
if length < 0 || length > maxFrameSize {
    return
}
```

---

### Significant Non-Blocking — `RegisterAgent` does not return a stable `host_id`

**File:** `internal/server/grpc/server.go:66`

The PR description and docs claim "stable UUID across reconnects via `ON CONFLICT … DO UPDATE` upsert." This is incorrect.

```go
hostID := uuid.NewString()   // fresh UUID on every call
h := storage.Host{HostID: hostID, ...}
s.store.UpsertHost(ctx, h)
```

The SQL in `UpsertHost` (`internal/server/storage/postgres.go:244`) resolves conflicts on `hostname` but does **not** update `host_id`:

```sql
ON CONFLICT (hostname) DO UPDATE SET
    ip_address    = EXCLUDED.ip_address,
    platform      = EXCLUDED.platform,
    ...
    -- host_id is NOT updated; the old UUID remains in the database
```

On every reconnect:
1. A new UUID is generated and returned to the agent.
2. The database retains the old UUID under that hostname.
3. `GetHost(ctx, newUUID)` returns not-found → hostname falls back to the UUID string.
4. New alerts are stored with the new UUID, breaking correlation with historical alerts and the host record.

This means the "stable host_id" guarantee the proto contract promises is silently violated on every agent reconnect. Alert correlation by host breaks after the first reconnect.

**Fix:** Before generating a new UUID, check whether a host with the given hostname already exists and return the existing `host_id`. Alternatively, modify `UpsertHost` to return the effective host_id (using `RETURNING host_id` or `INSERT … ON CONFLICT … DO UPDATE … RETURNING host_id`).

---

### Non-Blocking — All `stream.Recv()` errors treated as clean closure

**File:** `internal/server/grpc/server.go:113-118`

```go
evt, err := stream.Recv()
if err != nil {
    s.logger.Debug("grpc: StreamAlerts stream closed", slog.Any("reason", err))
    return nil   // swallows transport errors silently
}
```

Transport errors, auth errors, and resource exhaustion all return `nil` (success). The comment says "io.EOF (or context cancellation) signals normal stream close," but neither is checked. Real errors should be distinguished and returned (or at least logged at a higher level). This makes debugging connection problems difficult in production.

---

### Non-Blocking — No authentication on the WebSocket endpoint

`internal/server/websocket/handler.go` performs the RFC 6455 handshake but does no authentication. Any client that can reach the `/ws/alerts` route receives a real-time stream of all security alerts. If this endpoint is expected to be behind an auth-aware reverse proxy, that assumption should be documented explicitly. If not, add token or session validation in `ServeHTTP` before the hijack.

---

### Non-Blocking — No maximum frame size limit (related to blocking issue)

Even after fixing the int64 overflow, reading arbitrarily large client frames into `discarded := make([]byte, length)` is wasteful. Frames from browsers are tiny; a reasonable guard (e.g., 64 KiB) would prevent memory pressure from misbehaving or buggy clients. Consider using `io.CopyN(io.Discard, buf, length)` with a size cap to avoid the allocation entirely.

---

### Positive Observations

- Proto definition, generated code, and the `Store` interface boundary are clean.
- `Broadcaster` is correctly lock-free for the hot path via `sync.Map` and non-blocking `select`.
- Test coverage is solid: 16 scenarios across three files, including edge cases (null event_detail, zero timestamp, buffer-full drop).
- SHA-1 usage for WebSocket key derivation is correctly annotated with `//nolint:gosec` and justification.
- Documentation (`grpc-alert-service.md`) is thorough and consistent with the implementation.
- `go.mod` promotion of indirect to direct dependencies is correct.

**Action Required**: Please address the blocking issues above before merging.

---
*Reviewed by code-reviewer agent*